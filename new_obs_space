# 基于待运输队列处理的处理的状态空间 
##构建并返回传输代理的状态。状态是一个13维向量，基于待运输队列中的订单判断每个位置的状态。
    def calculate_state(self):
        # 初始化13维状态向量：1个source + 12个machine
        # 索引0：source，索引1-12：machine 1-12
        state_vector = [0.0] * 13
        
        # 获取所有工作站并按ID排序
        all_machines = []
        all_machines.extend(self.resources['machines'])
        all_machines.sort(key=lambda x: x.id)
        
        # 获取source
        source = self.resources['sources'][0]
        
        # 遍历待运输队列中的所有订单
        for order in Transport.all_transp_orders:
            if order.reserved:  # 跳过已预订的订单
                continue
            # 获取订单当前位置
            current_location = order.current_location
            # 判断订单的下一个处理步骤是否可用
            next_step = order.get_next_step()
            can_transport = False
            # 检查下一步是否可用
            if next_step.type == "sink":
                # 如果下一步是sink，总是可以运输
                can_transport = True
            elif next_step.type == "machine":
                # 检查机器工作站是否空闲
                if next_step.is_free():
                    can_transport = True
                # 检查是否有空闲的人工工作站
                elif next_step.is_free_hum():
                    can_transport = True
            # 如果可以运输，根据当前位置设置状态向量
            if can_transport:
                if current_location.type == "source":
                    # 订单在source位置
                    state_vector[0] = 1.0
                elif current_location.type == "machine":
                    # 订单在某个机器位置，找到对应的索引
                    machine_index = current_location.id
                    state_vector[machine_index-1] = 1.0
        return state_vector 

# get_action  ----------------
    def get_next_action(self):
        self.counter += 1
        self.parameters['step_criteria'].succeed()
        self.parameters['step_criteria'] = self.env.event()
        Transport.agents_waiting_for_action.append(self)
        yield self.parameters['continue_criteria']  # 等待环境计算出动作，需要知道小车运输的order和零件的destination
        # action_id = self.next_action[0]  # 环境给出的动作！！！！！！！！！！！！
        if self.agent_type != "TRPO":
            result_order, result_destination = self.agent.act(Transport.all_transp_orders)
            if result_order and result_destination:
                self.next_action_order = result_order
                result_origin = self.next_action_origin = result_order.current_location
                self.next_action_destination = result_destination
                result_valid = self.next_action_valid = True
                self.next_action[0] = result_destination.id
                step_progress_reward = 30 * (
                            self.next_action_order.actual_step / (len(self.next_action_order.prod_steps) - 1))
                # print("step_progress_reward=============================:", step_progress_reward)
                # # 零件等待时间奖励
                # order_waiting_time_reward = max(0.50, 1 / (1 + self.next_action_order.get_total_waiting_time()))
                # print("order_waiting_time=============================:", order_waiting_time_reward)
                self.next_action_reward = step_progress_reward 
            else:
                result_order = None
                result_origin = None
                result_destination = None
                self.next_action_valid = False
                self.next_action[0] = None
                print("无合法动作")
            # for o in self.all_transp_orders:
            #     print("waiting for transp:", o.id,[x.id for x in o.prod_steps],o.current_location.id,o.current_location.type,o.actual_step)
            return result_order, result_destination
        # 若是强化学习代理方法
        result_order = None
        result_origin = None
        result_dest = None
        result_valid=False
        # min_buffer_fill = 3 # 工作站缓冲区容量
        self.latest_reward = 0.0
        # 处理action_id为0的情况，从source缓冲区获取订单
        # 现在还有一个问题，如果缓冲区中有多个零件，处理哪一个零件会有更大的回报，以及如何选择。
        if self.mapping[self.next_action[0]] == 0:
            source = self.resources['sources'][0]
            if source.buffer_out:
                for order in source.buffer_out:
                    if order.get_next_step().is_free():
                        result_dest = order.get_next_step()
                        result_order = order
                        result_valid = True
                        break  # 找到第一个符合条件的订单就退出循环
        else:
            machine_id = self.mapping[self.next_action[0]]
            # 根据machine_id获取对应的工作站
            machine = next((m for m in chain(self.resources['machines'], self.resources.get(f'machine_group_{machine_id}', [])) 
                        if m.id == machine_id), None)
            # 如果找到工作站且其输出缓冲区有订单
            # 如果一开始只判断工作站上，那么source上永远不会有来运输的
            if machine.buffer_out:
                # 遍历缓冲区中的所有订单
                for order in machine.buffer_out:
                    # 如果下一个处理步骤是sink
                    if order.get_next_step().type == 'sink'and not order.reserved:
                        result_dest = order.get_next_step()
                        result_order = order
                        result_valid = True
                        result_order.reserved = True
                        break
                    # 如果订单的下一个处理步骤的工作站空闲
                    elif order.get_next_step().is_free() and order.reserved==False:
                        result_dest = order.get_next_step()
                        result_order = order
                        result_order.reserved = True
                        result_valid = True
                        break  # 找到第一个符合条件的订单就退出循环
                    # 检查同组是否有空闲人工站
                    elif order.get_next_step().type == "machine" and order.get_next_step().is_free_hum()and not order.reserved:
                        for mach in [x for x in chain(self.resources['machines'],
                                                    self.resources.get(f'machine_group_{order.get_next_step().machine_group}',[]))
                                    if x.machine_group == order.get_next_step().machine_group and x.machine_type == 2]:
                            # 由于只有一台人工工作站,直接将其作为目标工作站
                            result_dest = mach
                            result_order = order
                            result_valid = True
                            result_order.reserved = True
                        if result_order and result_dest: # 一次循环中 
                            break
                    if result_order and result_dest: # 如果找到订单，则跳出外层循环
                        break
        if result_order and result_dest: # 有效动作
            self.next_action_destination = result_dest
            self.next_action_order = result_order
            self.next_action_origin = result_order.current_location
            self.next_action_valid = result_valid
            result_order.prod_steps[result_order.actual_step] = result_dest # 更改产品的路径
            step_progress_reward = 30 * (
                        self.next_action_order.actual_step / (len(self.next_action_order.prod_steps) - 1))
            # print("step_progress_reward=============================:", step_progress_reward)
            # # 零件等待时间奖励
            # order_waiting_time_reward = max(0.50, 1 / (1 + self.next_action_order.get_total_waiting_time()))
            # print("order_waiting_time=============================:", order_waiting_time_reward)
            self.next_action_reward = step_progress_reward 
            # 将订单从transport_orders中pop出去
            Transport.all_transp_orders.pop(Transport.all_transp_orders.index(result_order))
            # result_order.current_location.buffer_out.pop(result_order.current_location.buffer_out.index(result_order))
        else:
            print("invalid action")
            self.next_action_destination = None
            self.next_action_order = None
            self.next_action_origin = None
            self.next_action_valid = False
        return result_order, result_dest #放回零件和destination 
